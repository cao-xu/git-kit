
#!/bin/bash
#
# gitmr: Merge Request Assistant (v4.0.1 - Bash 3.x Compatible)
#
# A script to automate the creation of Merge/Pull Requests.
#
# Core Features:
# 1. Interactively select a project from a user-defined list.
# 2. Interactively select a target branch.
# 3. Automatically uses the current branch as the source.
# 4. Intelligently converts SSH or HTTP Git remote URLs to a valid HTTPS MR link.
# 5. Automatically URL-encodes branch names with special characters (e.g., 'feature/add-login').
# 6. Smartly uses system clipboard and browser tools for a seamless experience.
#

set -e # Exit immediately if a command exits with a non-zero status.

# --- Utility and UI Functions ---
print_status() {
    local type="$1"
    local message="$2"
    local color_reset="\033[0m"
    local color_red="\033[0;31m"
    local color_green="\033[0;32m"
    local color_yellow="\033[0;33m"
    local color_blue="\033[0;34m"

    case "$type" in
        "error") echo -e "${color_red}âŒ Error: ${message}${color_reset}" >&2 ;;
        "success") echo -e "${color_green}âœ… ${message}${color_reset}" ;;
        "warning") echo -e "${color_yellow}âš ï¸ ${message}${color_reset}" ;;
        "step") echo -e "\n${color_blue}ðŸ¤” ${message}${color_reset}" ;;
        *) echo "$message" ;;
    esac
}

# --- Configuration Loader ---
# Looks for .git-kit-config in the project root, then in the user's home directory.
CONFIG_FILE_NAME=".git-kit-config"
PROJECT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
CONFIG_FILE=""

if [[ -n "$PROJECT_ROOT" && -f "$PROJECT_ROOT/$CONFIG_FILE_NAME" ]]; then
    CONFIG_FILE="$PROJECT_ROOT/$CONFIG_FILE_NAME"
elif [[ -f "$HOME/$CONFIG_FILE_NAME" ]]; then
    CONFIG_FILE="$HOME/$CONFIG_FILE_NAME"
fi

get_config_value() {
    local key="$1"
    if [[ -z "$CONFIG_FILE" ]]; then return; fi
    grep -E "^\s*${key}\s*=" "$CONFIG_FILE" | sed -E "s/^\s*${key}\s*=\s*//;s/\"//g" | tr -d '\r' | head -n 1
}

get_config_array() {
    local key="$1"
    if [[ -z "$CONFIG_FILE" ]]; then return; fi

    # New, more robust implementation using grep and sed instead of awk.
    # This avoids potential awk version/environment inconsistencies.
    grep -A 100 "${key}\s*=\s*(" "$CONFIG_FILE" \
    | sed '/)/q' \
    | grep -v -E "^\s*($|#|${key}\s*=|\))" \
    | sed -E 's/^\s*//;s/\s*$//;s/"//g'
}
# --- End of Configuration Loader ---


# --- Script-specific Configuration and State ---
# Using standard indexed arrays for maximum compatibility (Bash 3.x+).
project_names=()
project_ids=()
target_branches=()
TASK_LINK=""

# Function to load config specifically for gitmr
load_gitmr_config() {
    TASK_LINK=$(get_config_value "task_management_url")
    
    # shellcheck disable=SC2207
    target_branches=($(get_config_array "target_branches"))
    if [ ${#target_branches[@]} -eq 0 ]; then
        target_branches=("develop" "main" "master" "release" "test")
    fi
    
    # --- New Project Loading Logic (Bash 3.x Compatible) ---
    local temp_projects_data=()
    # shellcheck disable=SC2207
    temp_projects_data=($(get_config_array "projects"))

    if [ ${#temp_projects_data[@]} -eq 0 ]; then
        print_status "error" "No projects defined in '.git-kit-config'.\nPlease define at least one project under the [projects] section."
        exit 1
    fi

    # Ensure arrays are empty before loading
    project_names=()
    project_ids=()

    for item in "${temp_projects_data[@]}"; do
        # Use '%%' and '#' for safe string manipulation without external commands
        local nickname=${item%%=*}
        local data=${item#*=}
        local project_id=${data%%,*}

        project_names+=("$nickname")
        project_ids+=("$project_id")
    done
}


# --- Main Flow ---
main() {
    echo "ðŸš€ Welcome to the Merge Request Assistant (v4.0.1 - Compatible)!"
    echo "--------------------------------------------------"

    # --- [Step 1] Load Configuration ---
    load_gitmr_config

    # --- [Step 2] Interactively Select Project ---
    print_status "step" "Step 1/4: Select Project"
    local repo_id=""
    COLUMNS=1 # Force select menu into a single column
    PS3="Enter the number for your project: "
    select project_name in "${project_names[@]}"; do
        if [[ -n "$project_name" ]]; then
            # 'REPLY' is a built-in shell variable for the user's numeric input
            local selected_index=$((REPLY - 1))
            repo_id=${project_ids[$selected_index]}
            print_status "success" "Project selected: $project_name (ID: $repo_id)"
            break
        else
            print_status "warning" "Invalid selection. Please try again."
        fi
    done
    unset COLUMNS

    # --- [Step 3] Get Git Repository Info ---
    print_status "step" "Step 2/4: Reading Git Information"
    local repo_url
    repo_url=$(git config remote.origin.url)
    if [ -z "$repo_url" ]; then
        print_status "error" "Could not get the remote 'origin' URL from your Git config."
        exit 1
    fi
    
    local current_branch_raw
    current_branch_raw=$(git symbolic-ref --short HEAD)
    if [ -z "$current_branch_raw" ]; then
        print_status "error" "Could not get the current branch name. Are you in a detached HEAD state?"
        exit 1
    fi
    print_status "success" "Source Branch: $current_branch_raw"

    # --- [Step 4] Interactively Select Target Branch ---
    print_status "step" "Step 3/4: Select Target Branch"
    local target_branch_raw=""
    COLUMNS=1
    PS3="Enter the number for your target branch: "
    select target_branch_raw in "${target_branches[@]}"; do
        if [[ -n "$target_branch_raw" ]]; then
            print_status "success" "Target Branch: $target_branch_raw"
            break
        else
            print_status "warning" "Invalid selection. Please try again."
        fi
    done
    unset COLUMNS

    # --- [Step 5] Create Link and Provide Instructions ---
    print_status "step" "Step 4/4: Generating Link"
    
    # URL-encode branch names (crucial for branches with slashes like 'feature/add-auth')
    # Using sed is reliable and universally available.
    local source_branch_encoded
    source_branch_encoded=$(echo -n "$current_branch_raw" | sed 's,/,%2F,g')
    local target_branch_encoded
    target_branch_encoded=$(echo -n "$target_branch_raw" | sed 's,/,%2F,g')

    # Convert Git URL (SSH or HTTP) to a usable HTTPS Web URL
    local https_repo_path
    https_repo_path=$(echo "$repo_url" | sed -e 's,git@\(.*\):,https://\1/,' -e 's,\.git$,,')

    # Assemble the final URL
    local full_url="${https_repo_path}/-/merge_requests/new?sourceProjectId=${repo_id}&targetProjectId=${repo_id}&sourceBranch=${source_branch_encoded}&targetBranch=${target_branch_encoded}"

    # Handle Task Management Link
    if [[ -n "$TASK_LINK" ]]; then
        local os_name
        os_name=$(uname)
        local copy_cmd=""
        if [[ "$os_name" == "Darwin" ]]; then copy_cmd="pbcopy";
        elif [[ "$os_name" == "Linux" ]]; then
            if command -v xclip >/dev/null 2>&1; then copy_cmd="xclip -selection clipboard";
            elif command -v wl-copy >/dev/null 2>&1; then copy_cmd="wl-copy"; fi
        elif [[ "$os_name" == "MINGW"* || "$os_name" == "CYGWIN"* ]]; then copy_cmd="clip"; fi

        if [[ -n "$copy_cmd" ]]; then
            echo -n "$TASK_LINK" | $copy_cmd
            print_status "success" "[Auto] Task link copied to clipboard!"
        else
            print_status "manual" "Please copy your task link:\n   $TASK_LINK"
        fi
    fi

    # Handle the Merge Request Link
    local open_cmd=""
    if [[ "$os_name" == "Darwin" ]]; then open_cmd="open";
    elif [[ "$os_name" == "Linux" ]]; then open_cmd="xdg-open";
    elif [[ "$os_name" == "MINGW"* || "$os_name" == "CYGWIN"* ]]; then open_cmd="start"; fi

    if [[ -n "$open_cmd" ]] && command -v "$open_cmd" >/dev/null 2>&1; then
        "$open_cmd" "$full_url"
        print_status "success" "[Auto] Opening the Merge Request page in your browser..."
    else
        print_status "manual" "Please copy this URL into your browser:\n   $full_url"
    fi

    echo "--------------------------------------------------"
    echo "ðŸŽ‰ Done!"
}

# Run the main function
main "$@"
